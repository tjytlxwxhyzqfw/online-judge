# 040

如果是计数问题: 统计有多少种和是目标值的组合,
那么可以用DP来做:

(i, j, k): 从第i个元素开始选, 选用i号元素j次, 并且已有和是k, 求总共有多少种组合的和是目标值
跳转到(i+1, x, k+j*a[i]), x从0开始, 一直到和溢出位置

但是这个题是让我们把所有的组合都打印出来,
这样的话, 我选用了dfs:
(i, cursum, curpath): 从第i个元素开始, 已有和是cursum, 并且当前已选元素是curpath, 打印所有和是目标值的组合


DP貌似是可以解这个题的: [i, j, k]所有通过这种状态可以得到的组合
但是这样解貌似要花费好多好多空间啊...


DFS和DP应该有统一的形式, 换句话说, dpFill()内部不应该再有循环
而对于DFS, 除了驱动子函数外, 也不应该再有循环

**如果在一次实现这个题的话, 要改变现有的DFS的调用方式**
