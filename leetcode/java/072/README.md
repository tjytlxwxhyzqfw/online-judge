# 072

- 我先是以为不能用DP来解, 因为这个题的暴力解是个排列问题
- 我发现可以用DP来解, 硬为这个题还有一个指数搜索的暴力解
- 我发现指数搜索的暴力解是不可行的, 因为无法处理"删除"操作
- 答案还是DP, 这是经典的"最小编辑距离"问题, 这个DP的构建根LCS非常类似.

### 2017-04-15

第一次看成了: "交换"
这是不对的, 没有交换!!!!

还有一个失误, 是放过了DP, 这更是不对的!!!
诚然, 这个题的直接暴力解是个排列问题, 
但是, 它还可以表述成每个点都有插入/删除/替换三种选择的指数搜索问题啊!!!

有交换的话, 是不能DP的, 然而这题没有交换!!没有!!交换!!!

### 2017-04-16

(i, j): 已经同步了前i个字符, 现在正在同步第i个字符, 其中, 被编辑的字符已经被插入了j个字符
这个题DP是个不错的思路, 可是最终并不能用DP来做.
详见笔记.

### 答案: 还是用DP

最小编辑距离.
这个题是典型的"倒着思考"的方式, 即考虑状态(i, j)从哪个状态转移而来.

(i, j): 第一个字符串的前i个字符以及第二个字符串的前j个字符之间的距离.

百度: leetcode 72

#### 正着思考

我们从两个序列的中间开始考虑问题: s[i:]和t[j:]的最短编辑距离是多少?

(i, j)可以跳转到以下三个状态:

- (i+1, j): [i+1][j]+1
- (i, j+1): [i][j+1]+1
- (i+1, j+1): [i+1][j+1] 或者 [i+1][j+1]+1

#### 小总结

MED和LCS的思路都是 [i:, j:] = ?, 而不是传统的(i, j) -> ? => [i, j] = ?
详见笔记
