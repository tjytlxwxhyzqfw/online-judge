# 失败的思路

遍历已经填好的点, 设其值为x, 那么对于每个已经填好的点: 
	跟它同行的点, 不能填x
	跟它同列的点, 不能填x
	根它在同一个战区的点, 不能填x

遍历完所有已经填好的点后, 每个未填好的点, 都会有一个可填列表.

问题是, 每个可填列表里都有很多个元素, 你根本不知道选哪个.
这个题根**Codeforces填对话问题(390C)**不同, 那个题, 也是每个候选对话有很多个主人, 
但是那个题有个特点, 每个对话选择一个主人后, 只对相邻的对话产生影响, 因此可以DP. **请好好研究**
这个题的难点是, 每个点填上一个点后, 所有的点都受到影响了.

**Codeforces 390C 和本题的对比**: 这题绝不能用DP来做, 详细的对比和分析可以参见CSDN博客.

# 我的解法

每一行都有一个屏蔽码, 上面记录着这一行上不能填写的数字
每一列也有一个屏蔽码, 上面记录着这一列上不能填写的数字
每个小矩阵也有个屏蔽码, 上面记录着这个矩阵里面不能填写的数字.

dfs(x, y):
	x, y之前的元素已经填好了, 矩阵也已经更新到了相应的状态,
	现在填写(x, y)以及其后的所有元素, 并相应的更新状态, 
	请问能不能成功填写?

过程:

1. 保存所有全局变量的状态
2. 对于每个数字, 更新全局变量状态, 然后递归解决(y, x+1)
3. 若(y,x+1)解决成功, 直接返回成功
4. 否则, 恢复全局变量的状态, 然后遍历下一个数字
5. 如果所有的数字都不能成功填写, 这个状态是死的, 返回失败
	

		
			

		

