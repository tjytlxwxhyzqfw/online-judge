
我的解法:

1. 用栈去判断匹配
2. 当发生不匹配时, 清空计数器
3. 匹配结束后, 输出计数器的最大值

# 2017-03-08 22:25

- Submission Result: Wrong Answer More Details 
- Input: "()(()"
- Output: 4
- Expected: 2

要把字符串倒过来, 再解一次才行, 取两次的最小值

其实用栈检查括号的匹配性, 会出现两种错误:

1. 栈空: 一个右括号过来, 栈却空了
2. 栈不空: 字符串读完了, 栈里还有元素

# 2017-03-08 22:29

Test Case #5
--- input --->
((())())
--- output --->
s: ((())())
s: ))())(((
--------> 2

你应该意识到, 如果你的输入是(), 倒过来就是)(, 肯定不行

继续思考下去会让问题变复杂.

# 2017-03-08 22:35

必须修改解题思路, 这里的关键是检查哪个字符是"断点"

1. 从左到右遍历每个字符
2. 如果是左括号, 将其下标压栈
3. 如果是右括号, 尝试弹出, 如果不能弹出, 记录一个断点
4. 遍历结束后, 还在栈中的每个括号都是断点

断点记录好后, 开始统计字符

1. 从左到右开始统计字符
2. 每读一个字符, 计数器+1
3. 如果是断点, 计数器清零
4. 输出计数器的最大值

# 后记

超时..... O(n)的算法也超时.....  多次提交过了 .....
