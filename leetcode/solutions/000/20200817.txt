20200817.txt

写在前面
=======

扎姆境地, 读完一个题目, 一上来肯定是脑子一片空白的, 这时候我们需要一个思维上的切入点. 
对于模拟类的题目, 可能自然就有想法, 这个就很好.
其他的想法, 我感觉啊, 大多数的切入点都是一个类似于dp的思路: 如果要解决一个规模为n的问题, 那么可以尝试使用规模为[n-1]的问题来构造答案.

421G

描述: 给定一个数组, 从里面求两个数字, 最大化其XOR的值, 返回这个最大值.

1. 原解法什么鬼, 现在完全不懂啊? 操了
2. diss里面有种新解法, 我看行: 用所有数字构造一棵前缀树. 然后在树上依次搜索每个数字的补. 
   如果匹配不到怎么办? 注意, 每个节点最多只有两个儿子, 如果在节点p上匹配不到, 那么p就有且仅有1个儿子, 直接匹配这个唯一儿子即可.
   (disscuss中出现的新概念: bit trie, 貌似很多位运算题目都可以用这个工具来解? 学到了学到了)

423

描述: 给定一个数组, 它是one, tow, three, ..., nine这些单词排起来然后打乱字母顺序之后的形成的. 还原这个数字, 并从小到大地输出数字, 如123.

424G

描述: 给定一个大写字母组成的字符串, 你可以选择其中k个字母, 替换为任意字母. 请问, 替换完成之后, 最多可以有多少个连续的相同的字母?

今天的想法(AC, S=8): 用双指针法, 从左到右遍历, 再用一个最大堆来记录窗口内字母的计数. 总体比较复杂. 复杂度应该是nlogn, 因为这个堆的入栈次数和两个指针的步数相同(2n).

上次的做法: 对于26个大写字母, 每个字母解一遍这道题. 简单而且飞快. (但是仔细看上次的代码, 貌似又不是这种解法, 比这种解法要复杂很多.)

DISS中的做法: 跟我今天的思路一模一样. 不同的是, 人家不借助栈来维护最大次数. 事实上, 最大次数的维护非常容易: j右移时, 更新最大次数, 并替换. i右移时, 减少一个元素的最大次数, ***然后直接遍历所有元素的次数, 找到最大的那个元素***, 更新最大次数. (这么简单的做法我为啥想不到啊, 是不是一想到遍历找最小值, 就自动把这个思路给滤掉了啊? 太鸡儿蠢了)

427

描述: 给定一个正方形格子, 构造一棵四叉树: {左上, 右上, 左下, 右下}

429

描述: 给定一棵树, 从上到下, 从左到右, 一层一层地输出它的节点.

430

描述: 给定一个双链表. 每个元素有一个字段: child, 它指向另一个双链表. 现在要求把这个多层的双链表展开成一排. 
比如: x -> y 展开成: x -> x.child的展开 -> y.

今天的想法: 简单的栈就搞定了啊.
之前的解法: 用的DFS. 也还行吧, 就是感觉实现起来略绕, 而且不知道为啥wa了3次才过. 

433

描述: 给定两个ATCG基因序列: start, end, 以及一个基因集bank. 每次只能修改start中的一个基因, 问, 修改多少步能从start变为end? 要求: 从start到end的过程中, 所生成的所有中间序列必须全部位于bank中.

之前的想法: BFS
今天的想法: BFS

435G

描述: 给定若干个区间, 左闭右开, 从中删除最少的区间, 使得这些区间两两无交集. 求最少删除多少个?

今天的想法: 所有区间按照起点排序, 如果前两个区间重叠了, 那么永远删除那个尾巴更长的区间. 为什么这个想法是正确的? 
首先, 你得承认, 如果a和b重合了, 且a包含于b, 那么我们一定是删除b而不会删除a. 
那么, 对于前两个区间, 它们其实等价于开头一样(在他们的起点中间不会用第三个区间), 所以其实等价于尾巴更长的那个包含着尾巴更短的那个.

之前的想法1(WA): 直接没看懂, 怎么理解的啊?
之前的想法2(AC): 差不多跟我今天是一样的想法, 只不过用了一个双链表, 有点奇怪, 感觉用不到这种的.

436

描述: 给定若干个区间, 左闭右开. 对于每一个区间, 输出它右边的第一个区间(右边区间的起点大于等于左边区间的终点)

今天的想法: 起点排序, lower bound
之前的想法: 起点排序, lower bound

438

描述: 给定一个字符串s和一个子串p, 找到p的anagram在s中的所有出现的位置. anagram: 字母个数一样, 但排列不必样. 如ab和ba就是angram.

今天的想法: 这是一个标准的双指针模板问题. 现在这种题应该对我来说不难了, 所以就不加G了.

440H

自然数的字典序 -> 十叉树 -> 这个题好绕啊, 多搞几遍是不是就不绕了啊.

442

描述: 给定一个大小为n的数组以及 1 <= a[i] <= n, 数组中有些数字出现了两次, 而其他数字仅仅出现了一次, 找出所有的出现了两次的数字.

445

描述: 给定两个单链表表示两个数字x和y, 相加它们. (x和y只读哦)

今天的想法: 用栈啊...

之前的想法: 把x和y按照地位对齐, 假设x更长, 先把x复制到结果中(低位在前). 然后再把x+y的对应结果的和复制到结果中(不进位). 
   然后再进位, 进位完了之后再把结果链表反向并返回. 评(20200818): 好蠢啊, 直接用栈不好嘛?


446H

描述: 给定一个数组, 算出这个数组中所有的等差序列的个数. (连续或者不连续的都算)

今天的想法: 遍历所有的双数组合(a, b), 算出以a, b为基的等差序列. 怎么算呢?
	维护一张map: 数值 -> 出现的位置的列表(增序排列)
	对于数组中第3个数字c = b + (b-a), up_bound(map[c], b的idx)


上述这个解法跟392G的思路是一样的, 那个题目是找到s中所有值为t的子串.

450

描述: 从二叉查找树中删除一个节点.

451

描述: 给定一个字符串, 按照字母的频数排序

452G

描述: 一排气球, 要射多少箭才能把全部气球射爆?
想法: 见今天的golang实现吧

454G

描述:4个数组a, b, c, d. 求有都多少个四元组(i, j, k, l)满足: a[i]+b[j]+c[k]+d[l] = 0 ?
今天的想法: 2SUM可以在O(N)解决, 那么4Sum就可以拆成2Sum问题, 变成两个长为N^2的数组x, y, 然后有3个解法:
1. 在O(N^2LogN)解决: xy分别排序, 然后用2sum解决
2. 在O(N^2)解决: abcd分别各自排序后再merge成x, y, 可以避免对x, y的直接排序, 复杂度降低为O(n^2)
3. 在O(N^2)解决: 用HashMap, disscuss中多见这种解法. 所有的x中的数字放入hashmap, 然后y中的数字去hashmap中找对应.

加G的原因: 这个题目本身难度很低, 但是N-SUM问题比较经典, 而且可以借机回忆一下2SUM, 3SUM, 所有加了G

456G

描述: 找到一个整型序列中的132模式
加G: 谷歌面试题, 解法很多, 但是在我看来, 是对单调栈的深度考察, 而且跟之前好多单调栈类的题目都有联系.

完全没想法, 卡了我将近两个星期(其实是一想到要看这道题就头疼然后就玩手游去了...)

先说之前submission中的解法:

倒过来, 找231模式: 维护一个递减的单调栈, 和一个mid的变量, mid变量记录的是从栈中弹出的元素的最大值.
这样, mid的右边一定有一个比mid更大的值(因为它被弹出的原因就是因为碰到了一个更大的值).
所以只要我们再遍历的过程中, 碰到了一个比mid更小的值, 我们就找到了231模式. 

我们也可以论证, 如果有231模式, 上述算法一定能找到. 
设xyz就是231, 且y是所有231模式中的最大值, 而x是小于y的最大值. z是那个最小值. 
那么当y入栈的时候, x必然会被弹出且记录在mid中, 然后我们最后必然会发现一个z.

另一个想法是否可行? 能否正序直接找132模式?

很难, 为什么呢? 对于231模式, 我们用递减栈记录的是弹出元素的最大值, 也就是'2', 并且栈顶元素的意义始终都是那个'3'.
但是对于132模式, 如果我们还是用递减栈, 那么弹出的元素的最小值是'1', 但是栈顶元素没有意义. 它不是'3'. 栈底元素
也没有意义, 因为它不一定在'1'的右边.

这个题吸引我们去注意一个量: 在递减栈中的所有弹出的元素的最大值. 这个值并非是迄今为止的最大值. (而递减栈中所有弹出元素的最小值, 一定就是迄今为止的最小值)

我记得还有一道题, 我们关注的是栈右边还剩余的元素的数量. 那道题是从两个数组中选出N个数字, 组成一个最大的数. 可以找找看.

457G

描述: 给定一个整型循环数组, 元素的值表示移动步长, 请问里面是否含有一个环.
加G: 据说这个题目一般, 但是是个谷歌面试题, 并且, 设计一个很重的算法: 快慢指针. 等我找到一个快慢指针的更好题目后, 就可以把这个G去掉了.

diss: 凡是涉及到链上找环的, 多少跟快慢指针沾点关系.

458: JUST REMEMBER

描述: 给你n=1000桶水, 只有1桶水有毒, 猪喝下之后在d=15分钟内死亡, 再给你t=60分钟, 问, 最少需要多少头猪才能找到那桶有毒的水?

JUST REMEMBER: m头猪可以测试(t/d+1)^m桶水. 比如, 两头猪可以在t=60, d=15时测试25桶水. 为啥? t/d=4意味着我们可以做4组实验.
我们把25通水排成一个5x5的矩阵. 第一头猪按行喝, 第二头猪按列喝. 那么必能在4组实验内找到结果. 
同理, 如果有3头猪, 我们可以排出一个5x5x5的矩阵, ...

没道理的这道题目.

462G

描述: 给定一个数组, 一步=给一个数+1或者-1, 请问, 最少需要多少步, 才能让数组中所有的数相等?
加G是因为确实有给我卡主一次.

disscuss有两个思路:

1. 取中位数 => 但是证明过程比较繁琐, 而且不是很自然
2. 首尾做差法.

考虑2:

原数组从小到大排序=[a, b, c, d, e, f, g]
设最终值为 b < x < c, 则步数= x-a + x-b + c-x + d-x + e-x + f-x + g-x = g-a + f-b + e-x + d-x + c-x ... (1)
设最终值为 c < y < d, 则步数= y-a + y-b + y-c + d-y + e-y + f-y + g-y = g-a + f-b + e-c + d-y ... (2)
(1)-(2) = e-x + d-x + c-x - (e-c + d-y) = -x-x+c-x+c+y=-3x+2c+y=2(c-x)+(y-x)>0
所以我们大概可以分析出来, 取的数越往中间越好, 也就是最好取找那个中位数.

464G

描述: 给定n个数的数池{1, 2, ..., 20}, 和一个目标数t(<=300), 两个人玩游戏, 第一个人选一个, 第二个人再选一个, 不放回, 谁先让二人之和加到100, 谁就赢. 
问, 先手是否有必赢策略?

加G: 是因为确实又难到我了, 并且有一个重要的剪枝技巧值得学习. 这个题目, 除了记忆化搜索之外毫无其他解法. 答案也确实是记忆化搜索+剪枝.

有几个重要剪枝:

1. 如果总和小于目标数, 那么直接返回结果;
2. 先挑大数再挑小数, 这样能快速失败或成功, 进而达到剪枝目的 (好好学, 这是这个题目的重要剪枝技巧)

467G

描述: s是个无限循环序列: ..abc..wxyzabc.., p是一个长度>10000的任意小写字符串序列, 问, p中有多少个连续子串在s中出现?

今天的想法(错误): 尝试解决问题p[:i], 如果我知道了p[:j] (j<i)的所有答案(这个'答案'暂时是个模糊的概念)呢? len[i]表示以i为结尾的子串的长度.
如果p[i]能够和p[i-1]接在一起, 那么子串长度+1, 同时我们也就知道了以p[i]为结尾的子串的数量. 否则, len[i]=1. 另外, 这里需要考虑一个去重的问题.
怎么去重哦? 不会用map吧? 也太土了.

评: 这个想法是不对的. 如果子串数量巨大, 那么用map来去重的时候, 会生成一个巨大的map, 爆内存.

之前的想法(好): 我们来分别统计以a, b, ..., z为结尾的p的子串的最大长度. 然后累加即可. 为什么? 如果p中有一个以a结尾的长度为3的和一个以a结尾的长度为5的子串.
那么去掉那个长度为3的子串, 对最终答案没有影响(显然, 我之前对这个问题的理解更加深刻) 这种解法是可以不用去重的. 而且复杂度仅需要O(n).

468

描述: 给一个字符串, 判断它属于哪种类型的ip地址, 然后返回三个答案之一: {IPv4, IPv6, Neither}

470: JUST REMEMBER

描述: 给你函数rand7(),  实现函数rand10()

今天的想法: 难, 想不出来
答案: 用rand7() -> rand49()

太J8扯淡了, 这他妈, 就用rand7()实现出rand49(), 然后每次如果落在0-39就OK, 否则就重试.

472h

给你一个单词列表, 找出其中的"组合词". 组合词: 列表L中的单词X是组合词当且仅当X是L中若干个**短于**X的单词的拼接.

我的想法: 把所有单词放到一棵TRIE中, 然后用DFS去搜索. => 勉强过了, 但是据说还不如直接暴力破解.
好的想法: 动态规划: 判断一个单词是不是组合词: 用s[:i]来计算s[:i+1]是不是组合词.

详见代码

TODO: 479h(29%, 93/1336), 480H(38%, 1123/91), 483h(36%, 174/344), 488h(39%, 239/240), 493h(25%) 










