notes: 2020

392G: 今天的想法: 原题: i指向s的某个数, j指向t中的某个数, 消费i. 然后i右移一位, j也右移, 消费新的i. FollowUp: 把所有的s放入到一棵前缀树中. 遍历这颗前缀树. 假设i指向树中的某个节点, j指向t中的一个位置. 如果i.end==true, 记录i.isSubStr==true. 如果i是一个叶子节点, i回退到父亲, 同时j回退到i.父亲的.在t中的匹配位置(因此对于每个节点我们都要记录其在t中的匹配位置). 

分析: 上述解法, 对于每个s, 都要回退到某个t的某个位置, 可能可能存在对于每个s都要回退到t的开头重新找, 然后找到最后一个才发现匹配不到的极端情况, 这样的话, 就是|t|*|k|*|s|的复杂度了

diss中的想法1: 对t进行预处理, 建立一个map: 字母 -> 此字母在t中出现的位置列表. 这样的话, 对于s中的每个字母c, 我们找到c对应的列表, 然后二分查找即可. (c必须有一个序号, 这个序号大于c前继字母的序号)

分析: 很稳的解法, log|t| * |k|*|s|

diss中的想法2: 处理t, 每个字母都与它的所有后继字母相连, 这样t就变成了一个有向无环图. (如果t是aaaaaaaaaaaaaa)这样的模式, 这个图要怎么生成?). 然后对于每个s, 在DAG上过一遍, 就能找到s是否是个子串. 复杂度是X+|k|*|s|, X是前处理的复杂度, 有可能会比较大(t比较大的时候).

----- 从这个地方开始同步 ------

393: just remember: rules of utf8 encodinghah

394: 今天的想法: using a stack. 

395G: 今天的想法(错误): 记录整个子串中所有元素出现的次数. 哪些不够的, 记录为危险分子. 然后双指针遍历i在后j在前. 监视i和j之间是不是有满足条件的子串. 然后, 只要j指向了危险分子, 就立即前移i到一个j右边的不危险地方去.

反例: {危险分子, x, y, z, a, a, b, b, w, t, h, 危险分子}, k=2, 这个算法就失效了. 无法正确找到aabb这部分.

难点: 这个题直接应用双指针, 前指针可以自然前移, 但是后指针是无法驱动的, 即, 没有一个明确的条件能让后指针右移. 这个时候, 我们把问题划分成: 找最大的且仅含h个字母的窗口. h=1, 2, ..., 26. 这个时候后指针就有了一个右移的驱动, 双指针就转起来了. 这就是diss1(复杂度=O(n))中演示的思路.

我应该还见过不少类似的套路, 注意收集一下.

diss2(分治法): 将我今天的想法扩展一下, 我们可以按照危险分子, 不断的吧整个字符串切割成一块一块的, 然后在每一块上都递归的去切割. 直到找到一个子块, 它不含危险分子(仅统计这个子区间内的计数的条件下,不是危险分子)为止, 记录它的长度. 然后返回最长的. 复杂度大概是O(nlogn)的级别.

396: 设x是当前的和, y是x状态下循环右移一位之后的和, 那么可以总结出y = x + s - n*v. s是数组的总和, v是x状态下最右边的元素的值. (循环右移之后, 除了最后一个元素的系数清零之外, 所有其他元素的系数都+1, 因此可以轻易总结出上述规律)

397: 今天的想法是: 自顶向上直接递归. 偶数=1+{偶数/2}, 奇数=2+min{{奇数/2}, {奇数+1}/2}. 同时用一个hash map记录一下已经算过的数的值. (我想到的这个思路在diss中有人讨论过的, 是可以这样做的, 但是显然不如下面这种diss里的位处理解法)

disscuss: 对于这种问题, 将整数转为2进制数去找规律和找技巧是一个很常用的intuition, 但是这个我一直没有学到. 今天算是学到了.

398: 直接线性搜索这个数组可以, 将数字映射为idx列表也可以, 快排之后去做二分查找也可以. 

399G: 今天的想法: 有向图+DIJKSTRA/Bellman-Ford/Floyd/SPFA -> 无向图+BFS O(|query|*|equations|)

disscuss: BFS*DFS > {Bellman-Ford, Union-Find}

400G: 20200803
// description: put 1, 2, ..., 10, 11, ... numbers in a line, find the n-th digit.
// my idea today: #{len=1}=9, #{len=2}=90, #{len=3}=900, so we determine the length
// of the target first, len=3 for example, then we find the first 450 numbers
// then we split at 225 or (451+900)/2 (binary search). then we know the number.
// then we find the digit.
// disscuss: len=1, start=1, count=9.
//   while (n < len*count) { n-=len*count; start*=10; count*10; ++len; }
//   targetNum = start + (n-1)/len; // !!!!!!!!!!
//  1. 关注这个算法中的循环不变量: n, len, start, count
//  2. 注意目标数和n之间的关系. 假如目标长度是3, 那么n减去所有长度为1和2的数字个数, 剩下的就是在3位数中的位置.
//     然后 (n-1)/3 就表示落在第几个3位数中, 然后start+(n-2)/2就是目标数字了.
// 关于之前的解法: 看起来好累啊...想太多了吧我...

413: 20200814
描述: 给定一个整型数组, 里面有多少个长度>=3的等差序列?

416G: 20200814
描述: 给定一个正整数数组, 能否把它分成合相等的两个集合? (数组长度=200, 元素值<=100)
总结: 动态规划, dp[i][j]是一个具体问题, 我们要对这个具体问题的解空间做等价划分, 每个子空间的解都落在dp[][]中.
注意, 一定要是***等价划分***, 否则很容易就搞不明白为什么要这样去解. 然后就会发生混乱.

417: 20200814
描述: 给定一个2D数组, 左边上边是太平洋, 右边下边是大西洋, 洋流只能从大数流向<=的数, 求所有的能同时流向大西洋和太平洋的格子.
题目是个好题目, 但是这种BFS的思路感觉已经不难想到了, 所以没有加G.
问题是, 我之前居然用的是DFS做的, 太神奇了.
(扫了一眼DISS之后...)
DFS也不算神奇吧, 答案中很多都是用DFS来做的, 而且貌似还快那么一点. 
究其原因, 不过是因为这题目本质上是遍历节点而非路径, 
因此DFS是一种保留痕迹的DFS, 所以它也是一种遍历, 功能上跟BFS没什么区别. 
而由于DFS利用的是OS的栈, 所以反而还会比BFS的数组要快一点.

419: 20200814
描述: 给定一个2D数组, 每个格子上都有X和., x表示战船, 战船只能占据在同一行上或者同一列上. 不可能有相邻的战船. 求, 数组中有几条战船? (1次遍历)
今天的想法: 每一行都数一次, 数明白躺在这一行上的战船数量. 但是, 如果有个x, 他的上面那一行有个挨着的x, 那么就不计数(因为这是一条竖着的战船, 他已经在上面那一行计数过了).

421G: 20200814
描述: 给定一个数组, 这里面一定有两个数a和b, 使得a XOR b最大. 返回这个最大值.
今天的想法: 没思路呀. 只会按照最高位把数组分成两拨, 然后就懵逼了. 还是多看答案和DISS吧!


