    1157

2:
Intuition: (1) 就地逆序后相加; (2) 栈; (3) 递归
Discuss: 看错题了草, 人家本来就是倒序的

22:
Intuition: 递归

*=4的结果, 5的结果是否=()*和(*)?
(())(()) +() = {
	(*)
	()*
	+()+
} => 显然不是
用4个括号的所有结果去构造5对括号的所有结果是很难的

考虑用更细粒度的递归:
dfs(i, path, nleft) {
	if i == 2n {
		return
	}
	dfs(i+1, path+"(", ++nleft);
	dfs(i+1, path+")", --nleft) if (nleft > 0);
}

Discuss:
	放置"("的时候要注意啊, 也是有数量限制的啊!!!

42:
Intuition:
(1) 单调栈? 解不了
(2) 边界BFS那种的? 不行
问题是什么? 我得从左往右遍历, 但是我必须得知道右边的东西.
通常, 我只会一个处理这种问题的方法: 单调栈.
现在我又学会一个: 同时从左右向中间遍历.

Discuss:
(1) 蓄水问题: 二维的BFS是个好办法
(2) 蓄水问题: 一维的, 必须明白一个道理: 不管中间长什么样子, 只要低于当前左右边界的, 必有水.
	有多少水啊? 那么两面夹就行了


142:
Intuition: 但倍速指针和双倍速指针? 为什么?
Discuss: 真得去公司, 上午的功夫, 好好理解一下啊!!!

222:
Intuition: 统计一棵树是不是完全树, 并返回这颗树的order; 递归求解;
Discuss: 跟我的思路是一样的; 但是有递归的解法(没看哦)

282:
Intuition: dfs遍历所有可能性, 然后再写一个专门的函数求值
Discuss: 也是用DFS遍历, 但是遍历的同时就能够算出
1, 2, 3, 4

dfs(i, sum) {
	dfs(i+1, stack.push(a[i]))
	dfs(i+1, stack.push(-a[i]))
	dfs(i+1, stack.push(stack.pop()*a[i]))
}

// 上面的stack是别人没有的, 我后续写代码的时候可以考虑去掉的

322:
Intuition: dp[i][j] = min(dp[i-1][j], dp[i-1][j-a[i]], dp[i-1][j-2a[i]])
Discuss:
O(n*val), 好像有点印象, 但是究竟怎么做到的啊? 实在是搞不清楚.

这段代码是我自己的理解, 可能细节有点问题, 但是思路非常正确.

func (b *amBuilder) f(c []int, total int) {
	var dp []int
	for i := 0; i < total; i++ {
		// now we have the answers for (c, x) for all 0 <= x < i
		// so to reach i, we must pick a coin.
		// 这是最好的诠释: dp[i]这个状态是从之前的哪个状态转移过来的?
		for j := 0; j < len(c); j++ {
			dp[i] = min(dp[i-c[j]]+1, dp[i])
		}
	}
}

402: 

Intuition: 

31415 k=1 1415
      k=2 115

删去k个数 -> 使剩下的最小
选择k个数 -> 使剩下的最小->不行 (301)

3141592653 k=5
^ ^  ^

for i := 0; i < len(a); ++i {
	for (a[i] < stack.top()) stack.pop()
}

这就是一个单调栈的问题, 再处理一下边界情况就行了.
然后看了一眼通过率, 瑟瑟发抖.

Discuss: 思路跟我的是一样的, 但是, 确实, 边界太多, 不太好处理.

462:
Intuition: 
我猜不是中位数就是平均数
// 2 6 100
// avg: 36: 34+30+64
// mid: 6:  4+94
那肯定是中位数 -> 快排求中位数, 然后求解. 
证明一下为什么是中位数? 好像有点难度.

Discuss: 我的猜想是对的. 至于证明. discuss中真的有天才.
1. 首先, 目标数字必须在min和max之间
2. 目标数字不管在哪里, (max-x) + (x-min) = max - min是个常数
3. 所以去掉(min, max)两个元素, 回到1
到最后这个数字是谁? 中位数呀!

522:
Intuition: 暴力解; 每个生成幂集; 挨个匹配; 1024*50*10*50
Discuss: 排序, 最长的无重复? 直接就是答案; 否则, 判断短的是不是长的的子串, 只要它不是, 它就是答案;

662:
Intuition: BFS肯定不行; 
沿着有边界走一次, 记录每个节点在这一层上的序号
再沿着左边界走一次, 也是记下序号; 最后做差即可;
每个节点在这一层上的序号跟什么有关? 会不会跟从跟上到这里的路径有关?
卧槽还真有关. 左走是0, 右走是1; 那么左左左的点序号是0, 左右右的点序号是3....
Discuss: 
二叉树能用数组表示, 你知道吧?
你知道了二叉树的根的序号, 就知道了它的左右儿子的序号, 对吧?
那么问题不就解决了吗?

和我的思路都一样, 都整挺好.

822:
Intuition: 啥思路都没有, 直接搜索答案空间. 貌似可行. 最小的不是正反一样的那个数字就是答案;
Discuss: same

842:
Intuition: 这个序列备被前两个数字决定, 直接暴力搜索
Discuss: TODO

962:
Intuition: MergeSort可解NLogN
Discuss: 提示: 单调栈+O(N)

3 1 4 1 5 9 2 6
3 1 4 1 2




































