total: 18

5
---


今天的想法: 错误:
dp[i+1] = max:
	(1) dp[i] + 2
	(2) 1 or 2

上述判断方法***非常危险***:
反例1: aaa: dp[0] = 1, dp[1] = 2, dp[2] = 2 (其实是3)
反例2: abab: dp[0] = 1, dp[1] = 1, dp[2] = 3, dp[3] = 1 (其实是3)
其实我之前有过经验了, 回文字符串, 很少有O(n)的算法, 大部分是O(n^2)的算法.


我认为, 按照长度遍历二维数组是处理回文串的一个比较好的方法:

for i := 0; i < len(); i++ {
	for j := 0; j + i < len(); j++ {
		dp[j][j+i] = xxx
	}
}

通过以下方式判定回文:

dp[j][j+i] = true if:
	(1) i == 0 or i == 1 && s[j] == s[j+1]
	(2) dp[j+1][j+i-1] && s[j] == s[j+i]

评论区有个ExtendPalindrome(s, i, j): 以s[i]s[j]为回文序列的中心(可能重合), 来向左右延伸.

25: 好像也不算难啊, 除了编码可能有点绕之外
45: bfs一眼看穿
85: 转化为水柱问题, 利用单调栈求解. 主题: 雨水问题等
105: => 递归+HashMap, 问题不大
385: 递归解法(intuition), 迭代解法(diss, 其实比想象中简单)
      遇到递归的数据结构总是第一步想到递归, 这种思维方式是对的, 因为我就是递归滴神!!!
      但是, 递归之后, 可以稍微多走一步, 想一想迭代的解法.
445: 两个想法都在diss中体现了. (1) 借用双栈间接倒序两个输入; (2) 借用双指针对齐; 再直接不进位加; 再(利用栈)处理进位;
525: (有趣)
     第一反应: 前缀和: z[i]=[0, i]之间0的数量 -> 分析卡主
     双指针: 后指针无法驱动
     dp: 需要三个状态: e[i](等), z[i](0多1), w[i](1多1) => 算不出来的
     卡主...想...想到了: 前缀和的差是个很重要的工具
     first[z-w] = index
     对于i而言, delta[i]表示0比1多多少(z-w), 那么如果delta[i] = x, 那么以i结尾的最长序列的开始点就是first[x]+1
