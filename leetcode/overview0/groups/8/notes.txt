20 problems total

164: 在[min, max]之间插入n个元素, 那么必有两个元素的差大于或等于 (max-min)/(n+1)
	所以我可以设置若干个大小为 (max-min)/(n+1)的桶, 并记录桶内元素的最大最小值,
	那么最大的差必然出现在桶内, 或者相邻的n个桶;

264: UglyNumber(UN):
	任何一个UN都可以写成 x*p[i]的形式, 当这个un入队之后, 下一个可以写成x*p[i]的形式的un
	是紧挨着x的下一个un * p[i]

324: 只能想到一个快拍找中位数; 然后前后分开. 然后前一半放一个, 后一半放一个;
 递归要用OS栈; 不算O(1); 然后平均时间是O(n); 最坏是O(n^2)
 确实是中位数; 但是放置方法要难很多!!!
 中位数自己可能由于重复, 会挨在一起; 所以采用以下放法:

 1. 小数从左往右放; (注意第一个总是小数, 所以小数总是占据偶数的index)
 2. 大数从右往左放; (总是占据奇数)
 3. 剩下的放M; 问题不大, 因为剩下的不可能再有连续的格子了

 424:

 双指针

i ..... j
