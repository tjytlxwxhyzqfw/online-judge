notes.txt

33:
I: 二分两次/第一次找旋转点/第二次找到目标值
D: 基本上也跟我的思路一致, 这道题目差不多已经完结了.

73:
I: 每发现一个0, 就把这一行第一列和第一行的元素设置成0; 然后再遍历2次全部设成0;
D: 不用遍历两次; 遍历一次然后检查行首和列首是否为0就行了;

93:
I: 用DFS来解; DFS好像有重复; 可以中间加个记忆元素;
D: DFS确实可以; 但是还可以用好几层for循环来做...

113:
I: 直接DFS搜啊....
D: 好多解法

133:
I: DFS...
D: BFS/DFS...

233:
I: 十叉树/处理最高位/然后递归地去处理地位
D: 不太想看了....

313: 第一次还是做错了, 见IPAD吧

473: 我也想到了DFS, 而且, 凡是确定是DFS的, 一定要考虑剪枝. 
这是个重要的意识, DFS的剪枝意识.

673:

说明普通的LIS的算法的正确性
	(1) 算法能找到一个上升的子序列 => 
		每个元素被加入(append or insert)的时候, 对它前面的元素做一个快照, 快照有两个性质:
			(1) x的快照中的元素都比x小; (2) x的快照中的元素都在x的左边;
		当算法结束之后. 从最后一个元素开始, 从右向左依次还原快照. 出现一个上升的子序列. 
	(2) 如果abcdefg是最长上升子序列, 那么这个算法一定能找到 => 自行说明就行了.

对于这个题目, 没有必要往普通的上面去靠, 一个普通的O(n^2的DP就能解)

dp[i], len[i]
dp[j] += dp[i] for i < j && len[i]最大

for (int i = 0; i < dp.length; ++i) {
	for (int j = i-1; j >= 0; --j) {
		if (a[i] <= a[j] || len[i] > len[j]) {
			continue;
		}
		if (len[i] = len[j]) {
			dp[i] += dp[j];
			continue;
		}
		len[i] = len[j];
		dp[i] = dp[j];
	}
	++len[j];
}

713:
I: 正常的前缀和算法会溢出; 硬算会超时; 找不到好的处理办法;
	观察到每个数字的值域很小, 但是不知道怎么用这个条件
D: 双指针/可惜/罕见的, 双指针解法我居然没发现

813: 

I: 
dp[i][k] = max {
	dp[i-1][k] - (sum[i-1][k])/(cnt[i-1][k]) + (sum[i-1][k]+a[i])/(cnt[i-1][k]+1)
	dp[i-1][k-1] + a[i]
}

错的, 详见ipad11

853:

[3, 1, 4, 1, 5, 9] [2, 7, 1, 8, 2, 8]

[9, 5, 4, 3, 1, 1] [2, 7, 1, 8, 2, 8]

[a, b, c, d, e, f]

快 ------> 慢
a, b, c, ====> 单调栈 ===> 问题解决

(target-9)/2
()

time[i] = (target - pos[i])/speed

