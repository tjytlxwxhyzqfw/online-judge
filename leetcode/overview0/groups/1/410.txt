Intution:

思路一: 分治

分成m个区间, 它一定有中间的区间吧!!!
假设中间的区间是[i, j], 那么问题就被1分为二, 分而治之
但是呢, 复杂度貌似略高...

思路二: DP方向可行不

1000*1000*50 = 10^6*50 = 5*10^7

前i个分成k个区间:
dp[i][k] = min{
	dp[i-1][k] => 最后一个区间的和不知道???
}

[i, j]之间分成k个区间:
dp[i][j][k] = min {
}

分治和DP不行的话, 基本上就是回溯了, 回溯也不行的话, 基本上就没啥套路了.
就得去硬找规律吗? => 不纠结咯

Discuss:

二分啊二分啊二分啊!!!
数值问题考虑二分啊!!!!
直接二分搜索答案空间啊!!!!

然后呢? 另一个思路, 还真的有一个DP解:

来, 延续我之前的思路:

前i个分成k个区间:
dp[i][k] = min { max(dp[j][k-1], sum(j+1, i)) }

反思:
这里突然想起了在leetcode讨论区读到的一个总结,
那个总结是说, 一个问题的切分, 有两种方式, 中间切或者从头/尾切
中间切开生成一个分治算法, 这个我理解了;
从头尾切开的话, 当时没读懂, 现在貌似懂了!!!
从头尾切开, 产生一个DP算法!!!!

考虑这个数组的某个位置: i
数组的解表述为dp[i][k]: 前i个数字分成k个区间
那么从尾部切下来一个区间的解我都知道的话, 那么上述思路就出来了啊!!!

我之前的误区是, 非尝试用dp[i-1][k]去构造解.
这是显然不对的. 单领出来这个考虑没有意义. 
一定要从"从尾巴上切除一个区间"的角度去思考问题!!!!
