
Intution:
---------

1. 动态规划? 显然不靠谱啊
2. 切开两半? 显然不靠谱啊
3. 全是小写字母 -> 退化成单字母问题 -> 然后解26遍? 没有角度啊

这个时候怎么办啊? 只能从模拟的思路入手了呀.
考虑预处理
每个单词w都在原字符串s中找到自己的所有起始位置
这样原字符串就退化为: 013342845
这时候, 只要找到连续|words|个不相同的数字就行了 => 就是很简单的双指针问题了~

难点在于: "找打w在原字符串s中出现的所有位置" => 复杂度稍高

Discuss:
--------

https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13658/Easy-Two-Map-Solution-(C%2B%2BJava)

里面的元素可以是重复的, 不过倒是也无所谓.
但是Disscuss中的解法貌似时间复杂度会好一些.
为什么会好一些? 人家没有字符串查找的操作

重点: 像这种问题, 字符串和单字母其实是没有任何区别的.
比如, 如果字典words中的长度都是1, 那么问题是很好解的.
如果不是1呢? 那么用个hashMap其实是一样的啊!

