# Codeforces Round 398

## A
**标记, D=2**

有一个变量你是始终知道的: 当前体积最大的零食

1. 每当一个零食掉下来, 就看看它是不是当前体积最大的那个零食  
2. 如果是, 就将这个零食以及之前积攒的零食全都摞上去
3. 如果不是, 就单纯地将这个零食记录在案


## B
**D=3.5**

###### 教训
我的思路是正确的, 可是思维漏洞有很多, 导致没对, 主要地漏洞包括:

1. 9:00下班, 我8:59来了, 怎么办? 假设服务时间是10分钟
2. 新的意识: break/continue, 当你使用其中一个关键字的时候, 请考虑是不是需要用另一个关键字代替
3. 检查! 如果你的代码中使用了long long, 请千万抓取所有的int来做检查!!!
4. 输入判定, n可能为0

###### 解题思路

你意识到, 访客的到来时间应该从以下几个时间中选取:

1. 队伍访客的服务结束时间
2. 队伍访客的: 到达时间, 到达时间-1, 到达时间+1(可能不需要)

假设将这些时间存放在数组b中,   
对于给定的时间点, 你可以在log(4*10^5)的时间内求出其等待时间:

1. 求出这个时间点在访客中的排名 ... log(400,000)
2. 计算前面一个访客的服务结束时间 ... 1
3. 计算本访客的服务开始时间 ... 1
4. 计算等待时间 ... 1
	
这是一个典型的二分搜索模型: for-bs

###### 意外收获

1. c++的set是自动排序的
2. python 的时间复杂度, 需要乘20
3. lower_bound和upper_bound的意义: 第一个/最后一个可插入位置i: 将新元素放在i, 原来的[i:]后移一格, 数组顺序不会改变

## C


## D


## E
