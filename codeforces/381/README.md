# Codeforces Round #381

做C题的时候,我犯了一个极度恶心的错误.</br>
我用我的debug函数 printa 去打印答案,</br>
也就是用printf("%5d")打印答案,</br>
一旦数字超过5位数,它们就连在一起了,而我就跪了.</br>

*后来整理答案的时候发现,就算不犯那个错误,我也解不对,*</br>
*可耻地舒了口气.*

## A
**公倍数**

你注意到,最多买3个a就一定能让n+k被4整除;</br>
同理,最多买3个c也一定能让n+k被4整除;</br>
b稍微麻烦一些,如果n不是偶数,你买几个b都不行,</br>
如果n是偶数,最多买1个,就能被4整除

那么,只要遍历{0,1,2,3}x{0,1}x{0,1,2,3}的所有三元组就可以了.

这题根377A很像.

## B
**前缀和,暴力**

你看他叙述起来很麻烦,其实很简单.</br>
求一个数列中所有正数的和.</br>

你可以用前缀和数组,但是我觉得暴力解也是可以的.</br>
前缀和数组的话,别忘了从第一个元素开始的前缀和要特殊处理哟</br>

## C
**鸽笼原理,双指针,区间**

我先说解法,再说明解法的正确性.

###### 第一步,读入所有区间,按照左端点排序
这一步要顺便计算出mex的值.

###### 第二步,填充所有的最短区间
最短区间也就是区间长度为mex的区间,最小mex的最大值决定于这些区间.</br>
从左到右遍历所有区间,对于位与最短区间里的格子, 依次填入{0, 1, ..., mex-1},</br>
填到mex-1后,回到0,然后继续填,填完为止

###### 第三步,填充剩余的格子

剩余的格子要分两类.

位于第一个最短区间右边的格子,依次从{mex-1, mex-2, ..., 0}顺序**从右向左**填充.</br>
这个过程要考虑到已经填好的数,比如第一个空格前,有个填好的数2,那么这个空格要填1.</br>
你注意到这个2可能是第三步填充的,也可能是第二步填充的.

位与第一个区间左边的格子,要依次从{mex-1, mex-1, ..., 0}的顺序**从左向右**填充.</br>
也是要考虑已经填好的数,比如当前空格后一个数2,那么当前空格要填1.</br>
同理,这个数可能是第三步填充的,也可能是第二步填充的.

###### 正确性

第二步的填充是没问题的,我们保证了任意连续的mex个已经填好的数一定是不同的.

下面来两个例子说明了第三步为什么要倒着填:

例子1: 位于第一个最短区间之前的数要倒着填

> 5 2</br>
> 3 5</br>
> 1 5

例子2: 位于第一个最短区间之后的数也要倒着填:

> 10 3</br>
> 1 4</br>
> 7 10</br>
> 4 8

## D

## E
